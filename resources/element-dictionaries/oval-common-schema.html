<html xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>OVAL Core Common Schema Element Dictionary</title>
   </head>
   <body bgcolor="#ffffff">
      <h1 align="center">- Open Vulnerability and Assessment Language -<br>Element Dictionary
      </h1>
      <ul>
         <li>Schema: Core Common</li>
         <li>Version: 5.11 Draft 1</li>
         <li>Release Date: 11/14/2012 8:00:00 AM</li>
      </ul>
      <p align="justify">The following is a description of the common types that are shared across the different schemas within Open Vulnerability
         and Assessment Language (OVAL). Each type is described in detail and should provide the information necessary to understand
         what each represents. This document is intended for developers and assumes some familiarity with XML. A high level description
         of the interaction between these type is not outlined here.
      </p>
      <p align="justify">The OVAL Schema is maintained by The MITRE Corporation and developed by the public OVAL Community. For more information, including
         how to get involved in the project and how to submit change requests, please visit the OVAL website at http://oval.mitre.org.
      </p>
      <hr noshade="true" size="5" width="100%">
      <hr noshade="true" size="5" width="100%">
      <h3><a name="deprecated_info"></a>&lt; deprecated_info  &gt;
      </h3>
      <p align="justify">The deprecated_info element is used in documenting deprecation information for items in the OVAL Language.  It is declared
         globally as it can be found in any of the OVAL schemas and is used as part of the appinfo documentation and therefore it is
         not an element that can be declared locally and based off a global type..
      </p><a href="oval-common-schema.html#DeprecatedInfoType">oval:DeprecatedInfoType</a><br><h3><a name="element_mapping"></a>&lt; element_mapping  &gt;
      </h3>
      <p align="justify">The element_mapping element is used in documenting which tests, objects, states, and system characteristic items are associated
         with each other. It provides a way to explicitly and programatically associate the test, object, state, and item definitions.
      </p><a href="oval-common-schema.html#ElementMapType">oval:ElementMapType</a><br><h3><a name="ElementMapType"></a>== ElementMapType ==
      </h3>
      <p align="justify">The ElementMapType is used to document the association between OVAL test, object, state, and item entities.</p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="88%">
            <colgroup span="4">
               <col width="200">
               <col width="*">
               <col width="80">
               <col width="80">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Child Elements</b></td>
               <td><b>Type</b></td>
               <td align="center"><b><font size="-1">MinOccurs</font></b></td>
               <td align="center"><b><font size="-1">MaxOccurs</font></b></td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">test</td>
               <td style="font-size: 90%"><a href="oval-common-schema.html#ElementMapItemType">oval:ElementMapItemType</a></td>
               <td align="center" style="font-size: 90%">1</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The local name of an OVAL test.</td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">object</td>
               <td style="font-size: 90%"><a href="oval-common-schema.html#ElementMapItemType">oval:ElementMapItemType</a></td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The local name of an OVAL object.</td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">state</td>
               <td style="font-size: 90%"><a href="oval-common-schema.html#ElementMapItemType">oval:ElementMapItemType</a></td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The local name of an OVAL state.</td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">item</td>
               <td style="font-size: 90%"><a href="oval-common-schema.html#ElementMapItemType">oval:ElementMapItemType</a></td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The local name of an OVAL item.</td>
            </tr>
         </table>
      </blockquote><br><h3><a name="ElementMapItemType"></a>== ElementMapItemType ==
      </h3>
      <p align="justify">Defines a reference to an OVAL entity using the schema namespace and element name.</p>
      <blockquote>
         <table bgcolor="#FFFFFF" border="0" cellpadding="0" cellspacing="0">
            <colgroup span="6">
               <col width="30">
               <col width="*">
               <col width="30">
               <col width="*">
               <col width="30">
               <col width="*">
            </colgroup>
            <tr>
               <td colspan="6"><b>Attributes:</b></td>
            </tr>
            <tr>
               <td colspan="6">
                  <hr>
               </td>
            </tr>
            <tr>
               <td align="center" width="30">-</td>
               <td style="font-weight:bold">target_namespace</td>
               <td width="30"></td>
               <td>xsd:anyURI</td>
               <td width="30"></td>
               <td>(optional)</td>
            </tr>
            <tr>
               <td></td>
               <td colspan="5" style="padding-bottom: 10px; font-size: 90%;">The target_namespace attributes indicates what XML namespace the element belongs to. If not present, the namespace is that
                  of the document in which the ElementMapItemType instance element appears.
               </td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table border="3" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="88%">
            <colgroup span="2">
               <col width="200">
               <col width="*">
            </colgroup>
            <tr bgcolor="#FAFAFA">
               <td><b>Simple Content</b></td>
               <td>xsd:NCName</td>
            </tr>
         </table>
      </blockquote><br><h3><a name="DeprecatedInfoType"></a>== DeprecatedInfoType ==
      </h3>
      <p align="justify">The DeprecatedInfoType complex type defines a structure that will be used to flag schema-defined constructs as deprecated.
         It holds information related to the version of OVAL when the construct was deprecated along with a reason and comment.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="88%">
            <colgroup span="4">
               <col width="200">
               <col width="*">
               <col width="80">
               <col width="80">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Child Elements</b></td>
               <td><b>Type</b></td>
               <td align="center"><b><font size="-1">MinOccurs</font></b></td>
               <td align="center"><b><font size="-1">MaxOccurs</font></b></td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">version</td>
               <td style="font-size: 90%">n/a</td>
               <td align="center" style="font-size: 90%">1</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The required version child element details the version of OVAL in which the construct became deprecated.</td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">reason</td>
               <td style="font-size: 90%">xsd:string</td>
               <td align="center" style="font-size: 90%">1</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The required reason child element is used to provide an explanation as to why an item was deprecated and to direct a reader
                  to possible alternative structures within OVAL.
               </td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">comment</td>
               <td style="font-size: 90%">xsd:string</td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The optional comment child element is used to supply additional information regarding the element's deprecated status.</td>
            </tr>
         </table>
      </blockquote><br><hr noshade="true" size="5" width="100%">
      <hr noshade="true" size="5" width="100%">
      <h3><a name="GeneratorType"></a>== GeneratorType ==
      </h3>
      <p align="justify">The GeneratorType complex type defines an element that is used to hold information about when a particular OVAL document was
         compiled, what version of the schema was used, what tool compiled the document, and what version of that tool was used. 
      </p>
      <p align="justify">Additional generator information is also allowed although it is not part of the official OVAL Schema. Individual organizations
         can place generator information that they feel are important and these will be skipped during the validation. All OVAL really
         cares about is that the stated generator information is there.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="88%">
            <colgroup span="4">
               <col width="200">
               <col width="*">
               <col width="80">
               <col width="80">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Child Elements</b></td>
               <td><b>Type</b></td>
               <td align="center"><b><font size="-1">MinOccurs</font></b></td>
               <td align="center"><b><font size="-1">MaxOccurs</font></b></td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">product_name</td>
               <td style="font-size: 90%">xsd:string</td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The optional product_name specifies the name of the application used to generate the file. Product names SHOULD be expressed
                  as CPE Names according to the Common Platform Enumeration: Name Matching Specification Version 2.3.
               </td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">product_version</td>
               <td style="font-size: 90%">xsd:string</td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The optional product_version specifies the version of the application used to generate the file.</td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">schema_version</td>
               <td style="font-size: 90%">n/a</td>
               <td align="center" style="font-size: 90%">1</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The required schema_version specifies the version of the OVAL Schema that the document has been written in and that should
                  be used for validation.
               </td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">timestamp</td>
               <td style="font-size: 90%">xsd:dateTime</td>
               <td align="center" style="font-size: 90%">1</td>
               <td align="center" style="font-size: 90%">1</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The required timestamp specifies when the particular OVAL document was compiled. The format for the timestamp is yyyy-mm-ddThh:mm:ss.
                  Note that the timestamp element does not specify when a definition (or set of definitions) was created or modified but rather
                  when the actual XML document that contains the definition was created. For example, the document might have pulled a bunch
                  of existing OVAL Definitions together, each of the definitions having been created at some point in the past. The timestamp
                  in this case would be when the combined document was created.
               </td>
            </tr>
            <tr>
               <td rowspan="2" style="vertical-align: top;">xsd:any</td>
               <td style="font-size: 90%">n/a</td>
               <td align="center" style="font-size: 90%">0</td>
               <td align="center" style="font-size: 90%">unbounded</td>
            </tr>
            <tr>
               <td colspan="3" style="font-size: 90%; text-align: justify;">The Asset Identification specification (http://scap.nist.gov/specifications/ai/) provides a standardized way of reporting
                  asset information across different organizations.Asset Identification elements can hold data useful for identifying what tool, what version of that tool was used, and identify
                  other assets used to compile an OVAL document, such as persons or organizations.To support greater interoperability, an ai:assets element describing assets used to produce an OVAL document may appear at
                  this point in an OVAL document.
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="MessageType"></a>== MessageType ==
      </h3>
      <p align="justify">The MessageType complex type defines the structure for which messages are relayed from the data collection engine. Each message
         is a text string that has an associated level attribute identifying the type of message being sent. These messages could be
         error messages, warning messages, debug messages, etc. How the messages are used by tools and whether or not they are displayed
         to the user is up to the specific implementation. Please refer to the description of the MessageLevelEnumeration for more
         information about each type of message.
      </p>
      <blockquote>
         <table bgcolor="#FFFFFF" border="0" cellpadding="0" cellspacing="0">
            <colgroup span="6">
               <col width="30">
               <col width="*">
               <col width="30">
               <col width="*">
               <col width="30">
               <col width="*">
            </colgroup>
            <tr>
               <td colspan="6"><b>Attributes:</b></td>
            </tr>
            <tr>
               <td colspan="6">
                  <hr>
               </td>
            </tr>
            <tr>
               <td align="center" width="30">-</td>
               <td style="font-weight:bold">level</td>
               <td width="30"></td>
               <td><a href="oval-common-schema.html#MessageLevelEnumeration">oval:MessageLevelEnumeration</a></td>
               <td width="30"></td>
               <td>(optional -- default='info')</td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table border="3" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="88%">
            <colgroup span="2">
               <col width="200">
               <col width="*">
            </colgroup>
            <tr bgcolor="#FAFAFA">
               <td><b>Simple Content</b></td>
               <td>xsd:string</td>
            </tr>
         </table>
      </blockquote><br><hr noshade="true" size="5" width="100%">
      <hr noshade="true" size="5" width="100%">
      <h3><a name="CheckEnumeration"></a>-- CheckEnumeration --
      </h3>
      <p align="justify">The CheckEnumeration simple type defines acceptable check values, which are used to determine the final result of something
         based on the results of individual components. When used to define the relationship between objects and states, each check
         value defines how many of the matching objects (items except those with a status of does not exist) must satisfy the given
         state for the test to return true. When used to define the relationship between instances of a given entity, the different
         check values defines how many instances must be true for the entity to return true. When used to define the relationship between
         entities and multiple variable values, each check value defines how many variable values must be true for the entity to return
         true.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>all&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'all' means that a final result of true is given if all the individual results under consideration are true.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>at least one&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'at least one' means that a final result of true is given if at least one of the individual results under consideration
                     is true.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p style="text-decoration: line-through;">none exist&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p style="text-decoration: line-through;">A value of 'none exists' means that a test evaluates to true if no matching object exists that satisfy the data requirements.</p>
                  <p style="text-decoration: none;"><strong>Deprecated As Of Version: </strong>5.3<br><strong>Reason: </strong>Replaced by the 'none satisfy' value. In version 5.3 of the OVAL Language, the checking of existence and state were separated
                     into two distinct checks CheckEnumeration (state) and ExistenceEnumeration (existence). Since CheckEnumeration is now used
                     to specify how many objects should satisfy a given state for a test to return true, and no longer used for specifying how
                     many objects must exist for a test to return true, a value of 'none exist' is no longer needed. See the 'none satisfy' value.<br><strong>Comment: </strong>This value has been deprecated and will be removed in version 6.0 of the language.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>none satisfy&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'none satisfy' means that a final result of true is given if none the individual results under consideration are
                     true.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>only one&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'only one' means that a final result of true is given if one and only one of the individual results under consideration
                     are true.
                  </p>
               </td>
            </tr>
         </table>
      </blockquote>
      <p align="justify">Below are some tables that outline how each check attribute effects evaluation. The far left column identifies the check attribute
         in question. The middle column specifies the different combinations of individual results that the check attribute may bind
         together. (T=true, F=false, E=error, U=unknown, NE=not evaluated, NA=not applicable) For example, a 1+ under T means that
         one or more individual results are true, while a 0 under U means that zero individual results are unknown. The last column
         specifies what the final result would be according to each combination of individual results. Note that if the individual
         test is negated, then a true result is false and a false result is true, all other results stay as is.
      </p>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  ||&#xD;
 check attr is ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 1+ | 0  | 0  | 0  | 0  | 0+ ||  True&#xD;
               || 0+ | 1+ | 0+ | 0+ | 0+ | 0+ ||  False&#xD;
     ALL       || 0+ | 0  | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               || 0+ | 0  | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               || 0+ | 0  | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  ||&#xD;
 check attr is ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  True&#xD;
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  False&#xD;
  AT LEAST ONE || 0  | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               || 0  | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               || 0  | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  ||&#xD;
 check attr is ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 1  | 0+ | 0  | 0  | 0  | 0+ ||  True&#xD;
               || 2+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  ** False **&#xD;
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  ** False **&#xD;
   ONLY ONE    ||0,1 | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               ||0,1 | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               ||0,1 | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  ||&#xD;
 check attr is ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  True&#xD;
               || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  False&#xD;
  NONE SATISFY || 0  | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               || 0  | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               || 0  | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote><br><h3><a name="ClassEnumeration"></a>-- ClassEnumeration --
      </h3>
      <p align="justify">The ClassEnumeration simple type defines the different classes of definitions. Each class defines a certain intent regarding
         how an OVAL Definition is written and what that definition is describing. The specified class gives a hint about the definition
         so a user can know what the definition writer is trying to say. Note that the class does not make a statement about whether
         a true result is good or bad as this depends on the use of an OVAL Definition. These classes are also used to group definitions
         by the type of system state they are describing. For example, this allows users to find all the vulnerability (or patch, or
         inventory, etc) definitions.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>compliance&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A compliance definition describes the state of a machine as it complies with a specific policy. A definition of this class
                     will evaluate to true when the system is found to be compliant with the stated policy. Another way of thinking about this
                     is that a compliance definition is stating "the system is compliant if ...".
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>inventory&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>An inventory definition describes whether a specific piece of software is installed on the system. A definition of this class
                     will evaluate to true when the specified software is found on the system. Another way of thinking about this is that an inventory
                     definition is stating "the software is installed if ...".
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>miscellaneous&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'miscellaneous' class is used to identify definitions that do not fall into any of the other defined classes.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>patch&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A patch definition details the machine state of whether a patch executable should be installed. A definition of this class
                     will evaluate to true when the specified patch is missing from the system. Another way of thinking about this is that a patch
                     definition is stating "the patch should be installed if ...". Note that word SHOULD is intended to mean more than just CAN
                     the patch executable be installed. In other words, if a more recent patch is already installed then the specified patch might
                     not need to be installed.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>vulnerability&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A vulnerability definition describes the conditions under which a machine is vulnerable. A definition of this class will evaluate
                     to true when the system is found to be vulnerable with the stated issue. Another way of thinking about this is that a vulnerability
                     definition is stating "the system is vulnerable if ...".
                  </p>
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="SimpleDatatypeEnumeration"></a>-- SimpleDatatypeEnumeration --
      </h3>
      <p align="justify">The SimpleDatatypeEnumeration simple type defines the legal datatypes that are used to describe the values of individual entities
         that can be represented in a XML string field. The value may have structure and a pattern, but it is represented as string
         content.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>binary&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The binary datatype is used to represent hex-encoded data that is in raw (non-printable) form. This datatype conforms to the
                     W3C Recommendation for binary data meaning that each binary octet is encoded as a character tuple, consisting of two hexadecimal
                     digits {[0-9a-fA-F]} representing the octet code.  Expected operations within OVAL for binary values are 'equals' and 'not
                     equal'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>boolean&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The boolean datatype represents standard boolean data, either true or false.  This datatype conforms to the W3C Recommendation
                     for boolean data meaning that the following literals are legal values: {true, false, 1, 0}.  Expected operations within OVAL
                     for boolean values are 'equals' and 'not equal'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>evr_string&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The evr_string datatype represents the epoch, version, and release fields as a single version string. It has the form "EPOCH:VERSION-RELEASE".
                     Comparisons involving this datatype should follow the algorithm of librpm's rpmvercmp() function. Expected operations within
                     OVAL for evr_string values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less than
                     or equal'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>fileset_revision&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The fileset_revision datatype represents the version string related to filesets in HP-UX. An example would be 'A.03.61.00'.
                     For more information, see the HP-UX "Software Distributor Administration Guide" (http://h20000.www2.hp.com/bc/docs/support/SupportManual/c01919399/c01919399.pdf).
                     Expected operations within OVAL for fileset_version values are 'equals', 'not equal', 'greater than', 'greater than or equal',
                     'less than', and 'less than or equal'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>float&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The float datatype describes standard float data.  This datatype conforms to the W3C Recommendation for float data meaning
                     it is patterned after the IEEE single-precision 32-bit floating point type.  The format consists of a decimal followed, optionally,
                     by the character 'E' or 'e', followed by an integer exponent.  The special values positive and negative infinity and not-a-number
                     have are represented by INF, -INF and NaN, respectively.  Expected operations within OVAL for float values are 'equals', 'not
                     equal', 'greater than', 'greater than or equal', 'less than', and 'less than or equal'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>ios_version&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The ios_version datatype describes Cisco IOS Train strings. These are in essence version strings for IOS. Please refer to
                     Cisco's IOS Reference Guide for information on how to compare different Trains as they follow a very specific pattern. Expected
                     operations within OVAL for ios_version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than',
                     and 'less than or equal'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>int&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The int datatype describes standard integer data.  This datatype conforms to the W3C Recommendation for integer data which
                     follows the standard mathematical concept of the integer numbers.  (no decimal point and infinite range)  Expected operations
                     within OVAL for int values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or
                     equal', 'bitwise and', and 'bitwise or'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>ipv4_address&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The ipv4_address datatype represents IPv4 addresses and IPv4 address prefixes (using CIDR notation). Legal values are represented
                     in dotted-quad notation ('a.b.c.d' where 'a', 'b', 'c', and 'd' are integers from 0-255), optionally followed by a slash ('/')
                     and either a prefix-length (an integer from 0-32) or a netmask represented in dotted-quad notation ('a.b.c.d' where 'a', 'b',
                     'c', and 'd' are integers from 0-255). Examples of legal values are '192.0.2.0', '192.0.2.0/32', and '192.0.2.0/255.255.255.255'.
                     Additionally, leading zeros are permitted such that '192.0.2.0' is equal to '192.000.002.000'. Expected operations within
                     OVAL for ipv4_address values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', 'less than or
                     equal', 'subset of', and 'superset of'.
                  </p>
                  <p>The 'subset of' operation is used to compare sets of IP addresses. When using this operation, an IP address prefix defines
                     the set of IP addresses as specified by CIDR notation and a IP address defines the set of one IP address. The result will
                     be 'true', if the actual set of IP addresses on the system is a subset of the set defined by the stated entity. This means
                     that every IP address in the set of IP addresses on the system must be present in the set of IP addresses defined in the stated
                     entity. Otherwise, the result will be 'false'.
                  </p>
                  <p>The 'superset of' operation is used to compare sets of IP addresses. When using this operation, an IP address prefix defines
                     the set of IP addresses as specified by CIDR notation and a IP address defines the set of one IP address. The result will
                     be 'true', if the actual set of IP addresses on the system is a superset of the set defined by the stated entity. This means
                     that every IP address in the set of IP addresses defined in the stated entity is present in the set of IP addresses on the
                     system. Otherwise, the result will be 'false'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>ipv6_address&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The ipv6_address datatype represents IPv6 addresses and IPv6 address prefixes (using CIDR notation). This datatype conforms
                     to the IETF specification RFC 4291 for textual representations of IPv6 addresses and IPv6 address prefixes (See Section 2.2
                     and 2.3). Expected operations within OVAL for ipv6_address values are 'equals', 'not equal', 'greater than', 'greater than
                     or equal', 'less than', 'less than or equal', 'subset of', and 'superset of'.
                  </p>
                  <p>The 'subset of' operation is used to compare sets of IP addresses. When using this operation, an IP address prefix defines
                     the set of IP addresses as specified by CIDR notation and a IP address defines the set of one IP address. The result will
                     be 'true', if the actual set of IP addresses on the system is a subset of the set defined by the stated entity. This means
                     that every IP address in the set of IP addresses on the system must be present in the set of IP addresses defined in the stated
                     entity. Otherwise, the result will be 'false'.
                  </p>
                  <p>The 'superset of' operation is used to compare sets of IP addresses. When using this operation, an IP address prefix defines
                     the set of IP addresses as specified by CIDR notation and a IP address defines the set of one IP address. The result will
                     be 'true', if the actual set of IP addresses on the system is a superset of the set defined by the stated entity. This means
                     that every IP address in the set of IP addresses defined in the stated entity is present in the set of IP addresses on the
                     system. Otherwise, the result will be 'false'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>string&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The string datatype describes standard string data. This datatype conforms to the W3C Recommendation for string data.  Expected
                     operations within OVAL for string values are 'equals', 'not equal', 'case insensitive equals', 'case insensitive not equal',
                     'pattern match'.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>version&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The version datatype represents a value that is a hierarchical list of non-negative integers separated by a single character
                     delimiter.  Note that any non-number character can be used as a delimiter and that different characters can be used within
                     the same version string.  So '#.#-#' is the same as '#.#.#' or '#c#c#' where '#' is any non-negative integer.  Expected operations
                     within OVAL for version values are 'equals', 'not equal', 'greater than', 'greater than or equal', 'less than', and 'less
                     than or equal'.
                  </p>
                  <p>For example '#.#.#' or '#-#-#-#' where the numbers to the left are more significant than the numbers to the right. When performing
                     an 'equals' operation on a version datatype, you should first check the left most number for equality. If that fails, then
                     the values are not equal. If it succeeds, then check the second left most number for equality. Continue checking the numbers
                     from left to right until the last number has been checked. If, after testing all the previous numbers, the last number is
                     equal then the two versions are equal. When performing other operations, such as 'less than', 'less than or equal', 'greater
                     than, or 'greater than or equal', similar logic as above is used. Start with the left most number and move from left to right.
                     For each number, check if it is less than the number you are testing against. If it is, then the version in question is less
                     than the version you are testing against. If the number is equal, then move to check the next number to the right. For example,
                     to test if 5.7.23 is less than or equal to 5.8.0 you first compare 5 to 5. They are equal so you move on to compare 7 to 8.
                     7 is less than 8 so the entire test succeeds and 5.7.23 is 'less than or equal' to 5.8.0. The difference between the 'less
                     than' and 'less than or equal' operations is how the last number is handled. If the last number is reached, the check should
                     use the given operation (either 'less than' and 'less than or equal') to test the number. For example, to test if 4.23.6 is
                     greater than 4.23.6 you first compare 4 to 4. They are equal so you move on to compare 23 to 23. They are equal so you move
                     on to compare 6 to 6. This is the last number in the version and since 6 is not greater than 6, the entire test fails and
                     4.23.6 is not greater than 4.23.6.
                  </p>
                  <p>Version strings with a different number of components shall be padded with zeros to make them the same size. For example,
                     if the version strings '1.2.3' and '6.7.8.9' are being compared, then the short one should be padded to become '1.2.3.0'.
                  </p>
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="ComplexDatatypeEnumeration"></a>-- ComplexDatatypeEnumeration --
      </h3>
      <p align="justify">The ComplexDatatypeEnumeration simple type defines the complex legal datatypes that are supported in OVAL. These datatype
         describe the values of individual entities where the entity has some complex structure beyond simple string like content.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>record&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The record datatype describes an entity with structured set of named fields and values as its content. The only allowed operation
                     within OVAL for record values is 'equals'. Note that the record datatype is not currently allowed when using variables.
                  </p>
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="DatatypeEnumeration"></a>-- DatatypeEnumeration --
      </h3>
      <p align="justify">The DatatypeEnumeration simple type defines the legal datatypes that are used to describe the values of individual entities.
         A value should be interpreted according to the specified type. This is most important during comparisons. For example, is
         '21' less than '123'? will evaluate to true if the datatypes are 'int', but will evaluate to 'false' if the datatypes are
         'string'. Another example is applying the 'equal' operation to '1.0.0.0' and '1.0'. With datatype 'string' they are not equal,
         with datatype 'version' they are.
      </p>
      <p><span style="font-weight:bold">Union of  </span><a href="oval-common-schema.html#SimpleDatatypeEnumeration">oval:SimpleDatatypeEnumeration</a>, <a href="oval-common-schema.html#ComplexDatatypeEnumeration">oval:ComplexDatatypeEnumeration</a></p><br><h3><a name="ExistenceEnumeration"></a>-- ExistenceEnumeration --
      </h3>
      <p align="justify">The ExistenceEnumeration simple type defines acceptable existence values, which are used to determine a result based on the
         existence of individual components. The main use for this is for a test regarding the existence of objects on the system.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>all_exist&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'all_exist' means that every object defined by the description exists on the system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>any_exist&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'any_exist' means that zero or more objects defined by the description exist on the system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>at_least_one_exists&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'at_least_one_exists' means that at least one object defined by the description exists on the system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>none_exist&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'none_exist' means that none of the objects defined by the description exist on the system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>only_one_exists&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A value of 'only_one_exists' means that only one object defined by the description exists on the system.</p>
               </td>
            </tr>
         </table>
      </blockquote>
      <p align="justify">Below are some tables that outline how each ExistenceEnumeration value effects evaluation of a given test.  Note that this
         is related to the existence of an object(s) and not the object(s) compliance with a state.  The left column identifies the
         ExistenceEnumeration value in question. The middle column specifies the different combinations of individual item status values
         that have been found in the system characteristics file related to the given object. (EX=exists, DE=does not exist, ER=error,
         NC=not collected) For example, a 1+ under EX means that one or more individual item status attributes are set to exists, while
         a 0 under NC means that zero individual item status attributes are set to not collected.  The last column specifies what the
         result of the existence piece would be according to each combination of individual item status values.
      </p>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  item status value count  ||&#xD;
  attr value   ||                           || existence piece is&#xD;
               ||  EX  |  DE  |  ER  |  NC  ||&#xD;
---------------||---------------------------||------------------&#xD;
               ||  1+  |  0   |  0   |  0   ||  True&#xD;
               ||  0   |  0   |  0   |  0   ||  False&#xD;
               ||  0+  |  1+  |  0+  |  0+  ||  False  &#xD;
 all_exist     ||  0+  |  0   |  1+  |  0+  ||  Error&#xD;
               ||  0+  |  0   |  0   |  1+  ||  Unknown&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Evaluated&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Applicable&#xD;
---------------||---------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  item status value count  ||&#xD;
  attr value   ||                           ||  existence piece is&#xD;
               ||  EX  |  DE  |  ER  |  NC  ||&#xD;
---------------||---------------------------||------------------&#xD;
               ||  0+  |  0+  |  0   |  0+  ||  True &#xD;
               ||  1+  |  0+  |  1+  |  0+  ||  True&#xD;
               ||  --  |  --  |  --  |  --  ||  False&#xD;
 any_exist     ||  0   |  0+  |  1+  |  0+  ||  Error&#xD;
               ||  --  |  --  |  --  |  --  ||  Unknown&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Evaluated&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Applicable&#xD;
---------------||---------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  item status value count  ||&#xD;
  attr value   ||                           ||  existence piece is&#xD;
               ||  EX  |  DE  |  ER  |  NC  ||&#xD;
---------------||---------------------------||------------------&#xD;
               ||  1+  |  0+  |  0+  |  0+  ||  True &#xD;
               ||  0   |  1+  |  0   |  0   ||  False&#xD;
at_least_one_exists  ||  0   |  0+  |  1+  |  0+  ||  Error&#xD;
               ||  0   |  0+  |  0   |  1+  ||  Unknown&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Evaluated&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Applicable&#xD;
---------------||---------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  item status value count  ||&#xD;
  attr value   ||                           ||  existence piece is&#xD;
               ||  EX  |  DE  |  ER  |  NC  ||&#xD;
---------------||---------------------------||------------------&#xD;
               ||  0   |  0+  |  0   |  0   ||  True &#xD;
               ||  1+  |  0+  |  0+  |  0+  ||  False&#xD;
 none_exist    ||  0   |  0+  |  1+  |  0+  ||  Error&#xD;
               ||  0   |  0+  |  0   |  1+  ||  Unknown&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Evaluated&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Applicable&#xD;
---------------||---------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  item status value count  ||&#xD;
  attr value   ||                           ||  existence piece is&#xD;
               ||  EX  |  DE  |  ER  |  NC  ||&#xD;
---------------||---------------------------||------------------&#xD;
               ||  1   |  0+  |  0   |  0   ||  True &#xD;
               ||  2+  |  0+  |  0+  |  0+  ||  False&#xD;
               ||  0   |  0+  |  0   |  0   ||  False&#xD;
 only_one_exists      ||  0,1 |  0+  |  1+  |  0+  ||  Error&#xD;
               ||  0,1 |  0+  |  0   |  1+  ||  Unknown&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Evaluated&#xD;
               ||  --  |  --  |  --  |  --  ||  Not Applicable&#xD;
---------------||---------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote><br><h3><a name="FamilyEnumeration"></a>-- FamilyEnumeration --
      </h3>
      <p align="justify">The FamilyEnumeration simple type is a listing of families that OVAL supports at this time.  Since new family values can only
         be added with new version of the schema, the value of 'undefined' is to be used when the desired family is not available.
         Note that use of the undefined family value does not target all families, rather it means that some family other than one
         of the defined values is targeted.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>catos&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The catos value describes the Cisco CatOS operating system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>ios&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The ios value describes the Cisco IOS operating system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>macos&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The macos value describes the Mac operating system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>pixos&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The pixos value describes the Cisco PIX operating system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>undefined&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The undefined value is to be used when the desired family is not available.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>unix&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The unix value describes the UNIX operating system.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>vmware_infrastructure&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The vmware_infrastructure value describes VMWare Infrastructure.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>windows&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The windows value describes the Microsoft Windows operating system.</p>
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="MessageLevelEnumeration"></a>-- MessageLevelEnumeration --
      </h3>
      <p align="justify">The MessageLevelEnumeration simple type defines the different levels associated with a message. There is no specific criteria
         about which messages get assigned which level. This is completely arbitrary and up to the content producer to decide what
         is an error message and what is a debug message.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>debug&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>Debug messages should only be displayed by a tool when run in some sort of verbose mode.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>error&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>Error messages should be recorded when there was an error that did not allow the collection of specific data.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>fatal&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A fatal message should be recorded when an error causes the failure of more than just a single piece of data.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>info&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>Info messages are used to pass useful information about the data collection to a user.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>warning&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>A warning message reports something that might not correct but information was still collected.</p>
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="OperationEnumeration"></a>-- OperationEnumeration --
      </h3>
      <p align="justify">The OperationEnumeration simple type defines acceptable operations. Each operation defines how to compare entities against
         their actual values.
      </p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>equals&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'equals' operation returns true if the actual value on the system is equal to the stated entity.  When the specified datatype
                     is a string, this results in a case-sensitive comparison.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>not equal&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'not equal' operation returns true if the actual value on the system is not equal to the stated entity.  When the specified
                     datatype is a string, this results in a case-sensitive comparison.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>case insensitive equals&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'case insensitive equals' operation is meant for string data and returns true if the actual value on the system is equal
                     (using a case insensitive comparison) to the stated entity.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>case insensitive not equal&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'case insensitive not equal' operation is meant for string data and returns true if the actual value on the system is
                     not equal (using a case insensitive comparison) to the stated entity.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>greater than&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'greater than' operation returns true if the actual value on the system is greater than the stated entity.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>less than&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'less than' operation returns true if the actual value on the system is less than the stated entity.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>greater than or equal&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'greater than or equal' operation returns true if the actual value on the system is greater than or equal to the stated
                     entity.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>less than or equal&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'less than or equal' operation returns true if the actual value on the system is less than or equal to the stated entity.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>bitwise and&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'bitwise and' operation is used to determine if a specific bit is set. It returns true if performing a BITWISE AND with
                     the binary representation of the stated entity against the binary representation of the actual value on the system results
                     in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int',
                     if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise and'
                     with the stated integer 4 (0100) returns 4 (0100). Since the result is the same as the state mask, then the test returns true.
                     If the actual value on your machine is 1 (0001), then the 'bitwise and' with the stated integer 4 (0100) returns 0 (0000).
                     Since the result is not the same as the stated mask, then the test fails.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>bitwise or&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'bitwise or' operation is used to determine if a specific bit is not set. It returns true if performing a BITWISE OR with
                     the binary representation of the stated entity against the binary representation of the actual value on the system results
                     in a binary value that is equal to the binary representation of the stated entity. For example, assuming a datatype of 'int',
                     if the actual integer value of the setting on your machine is 6 (same as 0110 in binary), then performing a 'bitwise or' with
                     the stated integer 14 (1110) returns 14 (1110). Since the result is the same as the state mask, then the test returns true.
                     If the actual value on your machine is 1 (0001), then the 'bitwise or' with the stated integer 14 (1110) returns 15 (1111).
                     Since the result is not the same as the stated mask, then the test fails.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>pattern match&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'pattern match' operation allows an item to be tested against a regular expression. When used by an entity in an OVAL
                     Object, the regular expression represents the unique set of matching items on the system.  OVAL supports a common subset of
                     the regular expression character classes, operations, expressions and other lexical tokens defined within Perl 5's regular
                     expression specification. For more information on the supported regular expression syntax in OVAL see: http://oval.mitre.org/language/about/re_support_5.6.html
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>subset of&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'subset of' operation returns true if the actual set on the system is a subset of the set defined by the stated entity.</p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>superset of&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The 'superset of' operation returns true if the actual set on the system is a superset of the set defined by the stated entity.</p>
               </td>
            </tr>
         </table>
      </blockquote><br><h3><a name="OperatorEnumeration"></a>-- OperatorEnumeration --
      </h3>
      <p align="justify">The OperatorEnumeration simple type defines acceptable operators. Each operator defines how to evaluate multiple arguments.</p>
      <blockquote>
         <table bgcolor="#F9F9F9" border="1" cellpadding="5" cellspacing="0" style="table-layout:fixed" width="95%">
            <colgroup span="2">
               <col width="250">
               <col width="*">
            </colgroup>
            <tr bgcolor="#F0F0F0">
               <td><b>Value</b></td>
               <td><b>Description</b></td>
            </tr>
            <tr>
               <td valign="top">
                  <p>AND&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The AND operator produces a true result if every argument is true. If one or more arguments are false, the result of the AND
                     is false. If one or more of the arguments are unknown, and if none of the arguments are false, then the AND operator produces
                     a result of unknown.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>ONE&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The ONE operator produces a true result if one and only one argument is true. If there are more than argument is true (or
                     if there are no true arguments), the result of the ONE is false. If one or more of the arguments are unknown, then the ONE
                     operator produces a result of unknown.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>OR&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>The OR operator produces a true result if one or more arguments is true. If every argument is false, the result of the OR
                     is false. If one or more of the arguments are unknown and if none of arguments are true, then the OR operator produces a result
                     of unknown.
                  </p>
               </td>
            </tr>
            <tr>
               <td valign="top">
                  <p>XOR&nbsp;&#xD;
                     					
                  </p>
               </td>
               <td>
                  <p>XOR is defined to be true if an odd number of its arguments are true, and false otherwise. If any of the arguments are unknown,
                     then the XOR operator produces a result of unknown.
                  </p>
               </td>
            </tr>
         </table>
      </blockquote>
      <p align="justify">Below are some tables that outline how each operator effects evaluation. The far left column identifies the operator in question.
         The middle column specifies the different combinations of individual results that the operator may bind together. (T=true,
         F=false, E=error, U=unknown, NE=not evaluated, NA=not applicable) For example, a 1+ under T means that one or more individual
         results are true, while a 0 under U means that zero individual results are unknown. The last column specifies what the final
         result would be according to each combination of individual results. Note that if the individual test is negated, then a true
         result is false and a false result is true, all other results stay as is.
      </p>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  ||&#xD;
  operator is  ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 1+ | 0  | 0  | 0  | 0  | 0+ ||  True&#xD;
               || 0+ | 1+ | 0+ | 0+ | 0+ | 0+ ||  False&#xD;
      AND      || 0+ | 0  | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               || 0+ | 0  | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               || 0+ | 0  | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  || &#xD;
  operator is  ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 1  | 0+ | 0  | 0  | 0  | 0+ ||  True&#xD;
               || 2+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  ** False **&#xD;
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  ** False **&#xD;
      ONE      ||0,1 | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               ||0,1 | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               ||0,1 | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  || &#xD;
  operator is  ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               || 1+ | 0+ | 0+ | 0+ | 0+ | 0+ ||  True&#xD;
               || 0  | 1+ | 0  | 0  | 0  | 0+ ||  False&#xD;
      OR       || 0  | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               || 0  | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               || 0  | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote>
      <blockquote>
         <table align="center" bgcolor="#FCFCFC" border="5" cellpadding="5" cellspacing="0">
            <tr>
               <td><br><pre>&#xD;
               ||  num of individual results  ||&#xD;
  operator is  ||                             ||  final result is&#xD;
               || T  | F  | E  | U  | NE | NA ||&#xD;
---------------||-----------------------------||------------------&#xD;
               ||odd | 0+ | 0  | 0  | 0  | 0+ ||  True&#xD;
               ||even| 0+ | 0  | 0  | 0  | 0+ ||  False&#xD;
      XOR      || 0+ | 0+ | 1+ | 0+ | 0+ | 0+ ||  Error&#xD;
               || 0+ | 0+ | 0  | 1+ | 0+ | 0+ ||  Unknown&#xD;
               || 0+ | 0+ | 0  | 0  | 1+ | 0+ ||  Not Evaluated&#xD;
               || 0  | 0  | 0  | 0  | 0  | 1+ ||  Not Applicable&#xD;
---------------||-----------------------------||------------------&#xD;
                    </pre></td>
            </tr>
         </table>
      </blockquote><br><hr noshade="true" size="5" width="100%">
      <hr noshade="true" size="5" width="100%">
      <h3><a name="DefinitionIDPattern"></a>-- DefinitionIDPattern --
      </h3>
      <p align="justify">Define the format for acceptable OVAL Definition ids. An urn format is used with the id starting with the word oval followed
         by a unique string, followed by the three letter code 'def', and ending with an integer.
      </p>
      <blockquote>oval:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*</blockquote><br><h3><a name="ObjectIDPattern"></a>-- ObjectIDPattern --
      </h3>
      <p align="justify">Define the format for acceptable OVAL Object ids. An urn format is used with the id starting with the word oval followed by
         a unique string, followed by the three letter code 'obj', and ending with an integer.
      </p>
      <blockquote>oval:[A-Za-z0-9_\-\.]+:obj:[1-9][0-9]*</blockquote><br><h3><a name="StateIDPattern"></a>-- StateIDPattern --
      </h3>
      <p align="justify">Define the format for acceptable OVAL State ids. An urn format is used with the id starting with the word oval followed by
         a unique string, followed by the three letter code 'ste', and ending with an integer.
      </p>
      <blockquote>oval:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*</blockquote><br><h3><a name="TestIDPattern"></a>-- TestIDPattern --
      </h3>
      <p align="justify">Define the format for acceptable OVAL Test ids. An urn format is used with the id starting with the word oval followed by
         a unique string, followed by the three letter code 'tst', and ending with an integer.
      </p>
      <blockquote>oval:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*</blockquote><br><h3><a name="VariableIDPattern"></a>-- VariableIDPattern --
      </h3>
      <p align="justify">Define the format for acceptable OVAL Variable ids. An urn format is used with the id starting with the word oval followed
         by a unique string, followed by the three letter code 'var', and ending with an integer.
      </p>
      <blockquote>oval:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*</blockquote><br><h3><a name="ItemIDPattern"></a>-- ItemIDPattern --
      </h3>
      <p align="justify">Define the format for acceptable OVAL Item ids. The format is an integer. An item id is used to identify the different items
         found in an OVAL System Characteristics file.
      </p><br><hr noshade="true" size="5" width="100%">
      <hr noshade="true" size="5" width="100%">
      <h3><a name="EmptyStringType"></a>-- EmptyStringType --
      </h3>
      <p align="justify">The EmptyStringType simple type is a restriction of the built-in string simpleType. The only allowed string is the empty string
         with a length of zero. This type is used by certain elements to allow empty content when non-string data is accepted. See
         the EntityIntType in the OVAL Definition Schema for an example of its use.
      </p><br><h3><a name="NonEmptyStringType"></a>-- NonEmptyStringType --
      </h3>
      <p align="justify">The NonEmptyStringType simple type is a restriction of the built-in string simpleType. Empty strings are not allowed. This
         type is used by comment attributes where an empty value is not allowed.
      </p><br></body>
</html>